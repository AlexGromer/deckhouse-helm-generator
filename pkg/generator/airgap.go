package generator

import (
	"fmt"
	"regexp"
	"sort"
	"strings"

	"github.com/deckhouse/deckhouse-helm-generator/pkg/types"
)

// ImageRef represents a container image reference found in templates.
type ImageRef struct {
	Repository string // e.g. "nginx" or "registry.example.com/app"
	Tag        string // e.g. "1.21" or "latest"
	Digest     string // e.g. "sha256:abc123..."
	FullRef    string // original full reference string
}

// imageRefRegex matches image references in YAML templates.
// Handles: image: nginx:1.21, image: registry.example.com/app:v2, image: nginx@sha256:abc
var imageRefRegex = regexp.MustCompile(`(?m)image:\s*["']?([^\s"']+)["']?`)

// ExtractImageReferences scans all templates in a chart for image references.
func ExtractImageReferences(chart *types.GeneratedChart) []ImageRef {
	if chart == nil {
		return nil
	}

	seen := make(map[string]bool)
	var refs []ImageRef

	for _, content := range chart.Templates {
		matches := imageRefRegex.FindAllStringSubmatch(content, -1)
		for _, match := range matches {
			if len(match) < 2 {
				continue
			}
			raw := strings.TrimSpace(match[1])

			// Skip Helm template expressions
			if strings.Contains(raw, "{{") || strings.Contains(raw, "}}") {
				continue
			}

			if seen[raw] {
				continue
			}
			seen[raw] = true

			refs = append(refs, parseImageRef(raw))
		}
	}

	return refs
}

// parseImageRef parses a raw image string into an ImageRef.
func parseImageRef(raw string) ImageRef {
	ref := ImageRef{FullRef: raw}

	// Check for digest reference: image@sha256:...
	if idx := strings.Index(raw, "@"); idx != -1 {
		ref.Repository = raw[:idx]
		ref.Digest = raw[idx+1:]
		return ref
	}

	// Check for tag: image:tag
	// Handle registry paths with ports like registry.example.com:5000/image:tag
	parts := strings.Split(raw, ":")
	switch len(parts) {
	case 1:
		ref.Repository = raw
		ref.Tag = "latest"
	case 2:
		// Could be repo:tag or host:port/image (no tag)
		if strings.Contains(parts[1], "/") {
			// host:port/image — no explicit tag
			ref.Repository = raw
			ref.Tag = "latest"
		} else {
			ref.Repository = parts[0]
			ref.Tag = parts[1]
		}
	default:
		// host:port/image:tag
		ref.Tag = parts[len(parts)-1]
		ref.Repository = strings.Join(parts[:len(parts)-1], ":")
	}

	return ref
}

// GenerateImageList generates images.txt content — one unique image per line, sorted.
func GenerateImageList(refs []ImageRef) string {
	if len(refs) == 0 {
		return ""
	}

	seen := make(map[string]bool)
	var images []string

	for _, ref := range refs {
		if !seen[ref.FullRef] {
			seen[ref.FullRef] = true
			images = append(images, ref.FullRef)
		}
	}

	sort.Strings(images)
	return strings.Join(images, "\n") + "\n"
}

// GenerateAirgapValues generates values-airgap.yaml with global.imageRegistry override.
func GenerateAirgapValues(_ []ImageRef, registry string) map[string]interface{} {
	return map[string]interface{}{
		"global": map[string]interface{}{
			"imageRegistry": registry,
			"imagePullSecrets": []interface{}{
				map[string]interface{}{
					"name": "airgap-registry-secret",
				},
			},
		},
	}
}

// GenerateMirrorScript generates mirror-images.sh with skopeo copy commands.
func GenerateMirrorScript(refs []ImageRef, targetRegistry string) string {
	var sb strings.Builder

	sb.WriteString("#!/usr/bin/env bash\n")
	sb.WriteString("# Mirror images to air-gapped registry\n")
	sb.WriteString("# Generated by dhg (Deckhouse Helm Generator)\n")
	sb.WriteString(fmt.Sprintf("# Target registry: %s\n\n", targetRegistry))
	sb.WriteString("set -euo pipefail\n\n")

	if len(refs) == 0 {
		sb.WriteString("echo 'No images to mirror.'\n")
		return sb.String()
	}

	// Deduplicate
	seen := make(map[string]bool)
	var uniqueRefs []ImageRef
	for _, ref := range refs {
		if !seen[ref.FullRef] {
			seen[ref.FullRef] = true
			uniqueRefs = append(uniqueRefs, ref)
		}
	}

	// Sort for deterministic output
	sort.Slice(uniqueRefs, func(i, j int) bool {
		return uniqueRefs[i].FullRef < uniqueRefs[j].FullRef
	})

	sb.WriteString(fmt.Sprintf("TARGET_REGISTRY=\"%s\"\n\n", targetRegistry))

	for _, ref := range uniqueRefs {
		source := fmt.Sprintf("docker://%s", ref.FullRef)
		// Build target: replace original registry with target
		targetImage := ref.FullRef
		// If image has a registry prefix, strip it for the target
		if strings.Contains(ref.Repository, "/") {
			parts := strings.SplitN(ref.Repository, "/", 2)
			if strings.Contains(parts[0], ".") || strings.Contains(parts[0], ":") {
				// Has explicit registry — replace it
				if ref.Digest != "" {
					targetImage = parts[1] + "@" + ref.Digest
				} else if ref.Tag != "" && ref.Tag != "latest" {
					targetImage = parts[1] + ":" + ref.Tag
				} else {
					targetImage = parts[1] + ":latest"
				}
			}
		}
		target := fmt.Sprintf("docker://${TARGET_REGISTRY}/%s", targetImage)
		sb.WriteString(fmt.Sprintf("skopeo copy %s %s\n", source, target))
	}

	sb.WriteString("\necho 'Image mirroring complete.'\n")
	return sb.String()
}
