package generator

import (
	"context"
	"fmt"
	"strings"

	"github.com/deckhouse/deckhouse-helm-generator/pkg/helm"
	"github.com/deckhouse/deckhouse-helm-generator/pkg/types"

	"sigs.k8s.io/yaml"
)

// SeparateGenerator generates separate Helm charts for each service group.
type SeparateGenerator struct {
	BaseGenerator
}

// NewSeparateGenerator creates a new SeparateGenerator.
func NewSeparateGenerator() *SeparateGenerator {
	return &SeparateGenerator{
		BaseGenerator: NewBaseGenerator(types.OutputModeSeparate),
	}
}

// Generate creates one Helm chart per service group.
func (g *SeparateGenerator) Generate(ctx context.Context, graph *types.ResourceGraph, opts Options) ([]*types.GeneratedChart, error) {
	if ctx.Err() != nil {
		return nil, ctx.Err()
	}

	// Group resources into logical services.
	groupResult, err := GroupResources(graph)
	if err != nil {
		return nil, fmt.Errorf("failed to group resources: %w", err)
	}

	if len(groupResult.Groups) == 0 {
		return []*types.GeneratedChart{}, nil
	}

	charts := make([]*types.GeneratedChart, 0, len(groupResult.Groups))

	for _, group := range groupResult.Groups {
		if ctx.Err() != nil {
			return nil, ctx.Err()
		}

		chart, err := g.generateChartForGroup(group, opts)
		if err != nil {
			return nil, fmt.Errorf("failed to generate chart for group %s: %w", group.Name, err)
		}
		charts = append(charts, chart)
	}

	return charts, nil
}

// generateChartForGroup creates a complete Helm chart for a single service group.
func (g *SeparateGenerator) generateChartForGroup(group *ServiceGroup, opts Options) (*types.GeneratedChart, error) {
	chartName := group.Name

	// Build Chart.yaml.
	chartMeta := helm.ChartMetadata{
		Name:        chartName,
		Version:     opts.ChartVersion,
		AppVersion:  opts.AppVersion,
		Description: fmt.Sprintf("Helm chart for %s", chartName),
		APIVersion:  "v2",
		Type:        "application",
		Keywords:    []string{"kubernetes", "deckhouse"},
	}
	chartYAML := helm.GenerateChartYAML(chartMeta)

	// Build flat values (no service name nesting).
	values := g.buildFlatValues(group)
	valuesYAML, err := marshalFlatValues(chartName, values)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal values: %w", err)
	}

	// Collect templates and rewrite value paths for flat structure.
	// Processor-generated templates reference .Values.services.<serviceName>.<kind>
	// but in separate mode, values are flat: .Values.<kind>.
	templates := make(map[string]string)
	for _, resource := range group.Resources {
		if resource.TemplatePath != "" && resource.TemplateContent != "" {
			content := rewriteTemplateForSeparateMode(resource.TemplateContent, resource.ServiceName)
			templates[resource.TemplatePath] = content
		}
	}

	// Generate _helpers.tpl.
	helpers := helm.GenerateHelpers(chartName)

	// Generate NOTES.txt.
	notes := helm.GenerateNOTES(chartName, []string{chartName})

	return &types.GeneratedChart{
		Name:      chartName,
		Path:      opts.OutputDir,
		ChartYAML: chartYAML,
		ValuesYAML: valuesYAML,
		Templates: templates,
		Helpers:   helpers,
		Notes:     notes,
	}, nil
}

// buildFlatValues builds flat values for a service group.
// Unlike universal mode, values are NOT nested under a service name.
func (g *SeparateGenerator) buildFlatValues(group *ServiceGroup) map[string]interface{} {
	values := make(map[string]interface{})

	// Organize resources by kind.
	resourcesByKind := make(map[string][]*types.ProcessedResource)
	for _, resource := range group.Resources {
		kind := resource.Original.GVK.Kind
		resourcesByKind[kind] = append(resourcesByKind[kind], resource)
	}

	// Build values per kind.
	for kind, resources := range resourcesByKind {
		if kind == "ConfigMap" || kind == "Secret" {
			// Always use nested structure for ConfigMaps and Secrets.
			kindMap := make(map[string]interface{})
			for _, resource := range resources {
				resourceName := sanitizeName(resource.Original.Object.GetName())
				kindMap[resourceName] = resource.Values
			}
			values[pluralizeKind(kind)] = kindMap
		} else if len(resources) == 1 {
			// Single resource: nest under kind key.
			values[kindToValuesKey(kind)] = resources[0].Values
		} else {
			// Multiple resources of same kind.
			kindMap := make(map[string]interface{})
			for _, resource := range resources {
				resourceName := sanitizeName(resource.Original.Object.GetName())
				kindMap[resourceName] = resource.Values
			}
			values[pluralizeKind(kind)] = kindMap
		}
	}

	return values
}

// marshalFlatValues marshals flat values to YAML with a header comment.
func marshalFlatValues(chartName string, values map[string]interface{}) (string, error) {
	if len(values) == 0 {
		return fmt.Sprintf("# Default values for %s\n# Generated by Deckhouse Helm Generator\n", chartName), nil
	}

	yamlBytes, err := yaml.Marshal(values)
	if err != nil {
		return "", err
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("# Default values for %s\n", chartName))
	sb.WriteString("# Generated by Deckhouse Helm Generator\n\n")
	sb.Write(yamlBytes)

	return sb.String(), nil
}

// rewriteTemplateForSeparateMode rewrites template content to use flat value paths.
// Replaces patterns like:
//   .Values.services.<svc>.<path> -> .Values.<path>
//   $svc := .Values.services.<svc> -> $svc := .Values
func rewriteTemplateForSeparateMode(content, serviceName string) string {
	if serviceName == "" {
		return content
	}

	// Replace $svc variable assignment pattern.
	// e.g., {{- $svc := .Values.services.frontend }} -> {{- $svc := .Values }}
	content = strings.ReplaceAll(content,
		".Values.services."+serviceName,
		".Values")

	return content
}
